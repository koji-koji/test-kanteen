/**
 * Playwright Custom Reporter for Test Kanteen
 */

import type {
  Reporter,
  FullConfig,
  Suite,
  TestCase,
  TestResult,
  FullResult,
} from '@playwright/test/reporter';
import { RuntimeCatalogBuilder } from '../shared/runtime-catalog-builder';
import { PlaywrightResultMapper } from './result-mapper';
import * as fs from 'fs/promises';
import * as path from 'path';

/**
 * Options for Kanteen Playwright Reporter
 */
export interface KanteenPlaywrightReporterOptions {
  /** Output directory */
  output?: string;
  /** Output formats */
  format?: string[];
  /** Verbose output */
  verbose?: boolean;
}

/**
 * Kanteen Playwright Reporter
 * Captures runtime test execution information from Playwright
 */
export default class KanteenPlaywrightReporter implements Reporter {
  private catalogBuilder: RuntimeCatalogBuilder;
  private mapper: PlaywrightResultMapper;
  private options: Required<KanteenPlaywrightReporterOptions>;
  private startTime?: Date;

  constructor(options?: KanteenPlaywrightReporterOptions) {
    this.options = {
      output: options?.output ?? './test-kanteen-runtime',
      format: options?.format ?? ['json', 'markdown'],
      verbose: options?.verbose ?? false,
    };

    this.catalogBuilder = new RuntimeCatalogBuilder(this.options);
    this.mapper = new PlaywrightResultMapper();

    if (this.options.verbose) {
      console.log('[Kanteen] Playwright Reporter initialized');
      console.log(`[Kanteen] Output: ${this.options.output}`);
      console.log(`[Kanteen] Format: ${this.options.format.join(', ')}`);
    }
  }

  /**
   * Called once before running tests
   */
  onBegin(config: FullConfig, _suite: Suite): void {
    this.startTime = new Date();
    this.catalogBuilder.startRun(this.startTime);

    if (this.options.verbose) {
      console.log('[Kanteen] Test run started');
      console.log(`[Kanteen] Projects: ${config.projects.length}`);
    }
  }

  /**
   * Called after a test has been finished
   */
  onTestEnd(test: TestCase, result: TestResult): void {
    // Map test result
    const testResult = this.mapper.mapTestResult(test, result);
    this.catalogBuilder.addTestResult(testResult);

    if (this.options.verbose) {
      console.log(
        `[Kanteen] Test completed: ${test.title} (${result.status})`
      );
    }
  }

  /**
   * Called after all tests have been run
   */
  async onEnd(_result: FullResult): Promise<void> {
    this.catalogBuilder.endRun(new Date());

    try {
      const catalog = this.catalogBuilder.build();

      // Set framework to playwright
      catalog.metadata.framework = 'playwright';

      // Output catalog
      await this.outputCatalog(catalog);

      if (this.options.verbose) {
        console.log('[Kanteen] Test run completed');
        console.log(
          `[Kanteen] Total tests: ${catalog.executionSummary.totalTests}`
        );
        console.log(`[Kanteen] Passed: ${catalog.executionSummary.passed}`);
        console.log(`[Kanteen] Failed: ${catalog.executionSummary.failed}`);
        console.log(
          `[Kanteen] Duration: ${catalog.executionSummary.totalDuration}ms`
        );
      }
    } catch (error) {
      console.error('[Kanteen] Error building catalog:', error);
    }
  }

  /**
   * Output catalog to files
   */
  private async outputCatalog(catalog: any): Promise<void> {
    const outputPath = path.resolve(process.cwd(), this.options.output);
    await fs.mkdir(outputPath, { recursive: true });

    for (const format of this.options.format) {
      if (format === 'json') {
        const jsonPath = path.join(outputPath, 'runtime-catalog.json');
        await fs.writeFile(jsonPath, JSON.stringify(catalog, null, 2), 'utf-8');

        if (this.options.verbose) {
          console.log(`[Kanteen] JSON catalog written to: ${jsonPath}`);
        }
      } else if (format === 'markdown') {
        const mdPath = path.join(outputPath, 'runtime-catalog.md');
        const markdown = this.generateMarkdown(catalog);
        await fs.writeFile(mdPath, markdown, 'utf-8');

        if (this.options.verbose) {
          console.log(`[Kanteen] Markdown catalog written to: ${mdPath}`);
        }
      }
    }
  }

  /**
   * Generate Markdown from catalog
   */
  private generateMarkdown(catalog: any): string {
    const lines: string[] = [];

    lines.push('# Runtime Test Catalog (Playwright)');
    lines.push('');
    lines.push(`> Generated by Test Kanteen v${catalog.metadata.version}`);
    lines.push('');

    // Metadata
    lines.push('## Metadata');
    lines.push('');
    lines.push(
      `- **Generated At**: ${new Date(catalog.metadata.generatedAt).toLocaleString()}`
    );
    lines.push(
      `- **Execution Date**: ${new Date(catalog.metadata.executionDate).toLocaleString()}`
    );
    lines.push(`- **Total Duration**: ${catalog.metadata.totalDuration}ms`);
    lines.push(`- **Source Files**: ${catalog.metadata.sourceFiles.length}`);
    lines.push('');

    // Execution Summary
    lines.push('## Execution Summary');
    lines.push('');
    lines.push(`- **Total Tests**: ${catalog.executionSummary.totalTests}`);
    lines.push(`- **Passed**: ${catalog.executionSummary.passed} ‚úÖ`);
    lines.push(`- **Failed**: ${catalog.executionSummary.failed} ‚ùå`);
    lines.push(`- **Skipped**: ${catalog.executionSummary.skipped} ‚è≠Ô∏è`);
    lines.push(`- **Pending**: ${catalog.executionSummary.pending} ‚è∏Ô∏è`);
    lines.push(`- **Todo**: ${catalog.executionSummary.todo} üìù`);
    lines.push('');

    // Test Results
    lines.push('## Test Results');
    lines.push('');

    for (const suite of catalog.testSuites) {
      this.generateSuiteMarkdown(suite, lines, 0);
    }

    return lines.join('\n');
  }

  /**
   * Generate Markdown for a test suite
   */
  private generateSuiteMarkdown(
    suite: any,
    lines: string[],
    depth: number
  ): void {
    const indent = '  '.repeat(depth);

    lines.push(
      `${indent}**${suite.name}**${suite.runtime ? ` (${suite.runtime.duration}ms)` : ''}`
    );

    if (suite.tests && suite.tests.length > 0) {
      for (const test of suite.tests) {
        const status = this.getStatusEmoji(test.runtime.status);
        lines.push(
          `${indent}  - ${status} ${test.name} (${test.runtime.duration}ms)`
        );

        if (test.runtime.error) {
          lines.push(`${indent}    - ‚ùå Error: ${test.runtime.error.message}`);
        }
      }
    }

    if (suite.nestedSuites && suite.nestedSuites.length > 0) {
      for (const nested of suite.nestedSuites) {
        this.generateSuiteMarkdown(nested, lines, depth + 1);
      }
    }

    lines.push('');
  }

  /**
   * Get status emoji
   */
  private getStatusEmoji(status: string): string {
    const emojis: Record<string, string> = {
      passed: '‚úÖ',
      failed: '‚ùå',
      skipped: '‚è≠Ô∏è',
      pending: '‚è∏Ô∏è',
      todo: 'üìù',
    };
    return emojis[status] || '‚ùì';
  }
}
