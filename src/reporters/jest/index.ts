/**
 * Jest Custom Reporter for Test Kanteen
 */

import type {
  Reporter,
  Test,
  TestResult,
  AggregatedResult,
  TestContext,
} from '@jest/reporters';
import { RuntimeCatalogBuilder } from '../shared/runtime-catalog-builder';
import { JestResultMapper } from './result-mapper';
import * as fs from 'fs/promises';
import * as path from 'path';

/**
 * Options for Kanteen Jest Reporter
 */
export interface KanteenJestReporterOptions {
  /** Output directory */
  output?: string;
  /** Output formats */
  format?: string[];
  /** Verbose output */
  verbose?: boolean;
}

/**
 * Kanteen Jest Reporter
 * Captures runtime test execution information from Jest
 */
export default class KanteenJestReporter implements Reporter {
  private catalogBuilder: RuntimeCatalogBuilder;
  private mapper: JestResultMapper;
  private options: Required<KanteenJestReporterOptions>;

  constructor(
    _globalConfig: any,
    options?: KanteenJestReporterOptions
  ) {
    this.options = {
      output: options?.output ?? './test-kanteen-runtime',
      format: options?.format ?? ['json', 'markdown'],
      verbose: options?.verbose ?? false,
    };

    this.catalogBuilder = new RuntimeCatalogBuilder(this.options);
    this.mapper = new JestResultMapper();

    if (this.options.verbose) {
      console.log('[Kanteen] Jest Reporter initialized');
      console.log(`[Kanteen] Output: ${this.options.output}`);
      console.log(`[Kanteen] Format: ${this.options.format.join(', ')}`);
    }
  }

  /**
   * Called when the test run starts
   */
  onRunStart(_results: AggregatedResult, _options: any): void {
    this.catalogBuilder.startRun(new Date());

    if (this.options.verbose) {
      console.log('[Kanteen] Test run started');
    }
  }

  /**
   * Called when a test file completes
   */
  onTestResult(
    _test: Test,
    testResult: TestResult,
    _results: AggregatedResult
  ): void {
    // Map Jest test results to TestResultData
    const testResults = this.mapper.mapTestResult(testResult);

    for (const result of testResults) {
      this.catalogBuilder.addTestResult(result);
    }

    if (this.options.verbose) {
      console.log(
        `[Kanteen] Processed ${testResults.length} tests from ${testResult.testFilePath}`
      );
    }
  }

  /**
   * Called when the test run completes
   */
  async onRunComplete(
    _contexts: Set<TestContext>,
    _results: AggregatedResult
  ): Promise<void> {
    this.catalogBuilder.endRun(new Date());

    try {
      const catalog = this.catalogBuilder.build();

      // Set framework to jest
      catalog.metadata.framework = 'jest';

      // Output catalog
      await this.outputCatalog(catalog);

      if (this.options.verbose) {
        console.log('[Kanteen] Test run completed');
        console.log(`[Kanteen] Total tests: ${catalog.executionSummary.totalTests}`);
        console.log(`[Kanteen] Passed: ${catalog.executionSummary.passed}`);
        console.log(`[Kanteen] Failed: ${catalog.executionSummary.failed}`);
        console.log(`[Kanteen] Duration: ${catalog.executionSummary.totalDuration}ms`);
      }
    } catch (error) {
      console.error('[Kanteen] Error building catalog:', error);
    }
  }

  /**
   * Output catalog to files
   */
  private async outputCatalog(catalog: any): Promise<void> {
    const outputPath = path.resolve(process.cwd(), this.options.output);
    await fs.mkdir(outputPath, { recursive: true });

    for (const format of this.options.format) {
      if (format === 'json') {
        const jsonPath = path.join(outputPath, 'runtime-catalog.json');
        await fs.writeFile(jsonPath, JSON.stringify(catalog, null, 2), 'utf-8');

        if (this.options.verbose) {
          console.log(`[Kanteen] JSON catalog written to: ${jsonPath}`);
        }
      } else if (format === 'markdown') {
        const mdPath = path.join(outputPath, 'runtime-catalog.md');
        const markdown = this.generateMarkdown(catalog);
        await fs.writeFile(mdPath, markdown, 'utf-8');

        if (this.options.verbose) {
          console.log(`[Kanteen] Markdown catalog written to: ${mdPath}`);
        }
      }
    }
  }

  /**
   * Generate Markdown from catalog
   */
  private generateMarkdown(catalog: any): string {
    const lines: string[] = [];

    lines.push('# Runtime Test Catalog (Jest)');
    lines.push('');
    lines.push(`> Generated by Test Kanteen v${catalog.metadata.version}`);
    lines.push('');

    // Metadata
    lines.push('## Metadata');
    lines.push('');
    lines.push(`- **Generated At**: ${new Date(catalog.metadata.generatedAt).toLocaleString()}`);
    lines.push(`- **Execution Date**: ${new Date(catalog.metadata.executionDate).toLocaleString()}`);
    lines.push(`- **Total Duration**: ${catalog.metadata.totalDuration}ms`);
    lines.push(`- **Source Files**: ${catalog.metadata.sourceFiles.length}`);
    lines.push('');

    // Execution Summary
    lines.push('## Execution Summary');
    lines.push('');
    lines.push(`- **Total Tests**: ${catalog.executionSummary.totalTests}`);
    lines.push(`- **Passed**: ${catalog.executionSummary.passed} ‚úÖ`);
    lines.push(`- **Failed**: ${catalog.executionSummary.failed} ‚ùå`);
    lines.push(`- **Skipped**: ${catalog.executionSummary.skipped} ‚è≠Ô∏è`);
    lines.push(`- **Pending**: ${catalog.executionSummary.pending} ‚è∏Ô∏è`);
    lines.push(`- **Todo**: ${catalog.executionSummary.todo} üìù`);
    lines.push('');

    // Test Results
    lines.push('## Test Results');
    lines.push('');

    for (const suite of catalog.testSuites) {
      this.generateSuiteMarkdown(suite, lines, 0);
    }

    return lines.join('\n');
  }

  /**
   * Generate Markdown for a test suite
   */
  private generateSuiteMarkdown(suite: any, lines: string[], depth: number): void {
    const indent = '  '.repeat(depth);

    lines.push(`${indent}**${suite.name}**${suite.runtime ? ` (${suite.runtime.duration}ms)` : ''}`);

    if (suite.tests && suite.tests.length > 0) {
      for (const test of suite.tests) {
        const status = this.getStatusEmoji(test.runtime.status);
        lines.push(
          `${indent}  - ${status} ${test.name} (${test.runtime.duration}ms)`
        );

        if (test.runtime.error) {
          lines.push(`${indent}    - ‚ùå Error: ${test.runtime.error.message}`);
        }
      }
    }

    if (suite.nestedSuites && suite.nestedSuites.length > 0) {
      for (const nested of suite.nestedSuites) {
        this.generateSuiteMarkdown(nested, lines, depth + 1);
      }
    }

    lines.push('');
  }

  /**
   * Get status emoji
   */
  private getStatusEmoji(status: string): string {
    const emojis: Record<string, string> = {
      passed: '‚úÖ',
      failed: '‚ùå',
      skipped: '‚è≠Ô∏è',
      pending: '‚è∏Ô∏è',
      todo: 'üìù',
    };
    return emojis[status] || '‚ùì';
  }
}
