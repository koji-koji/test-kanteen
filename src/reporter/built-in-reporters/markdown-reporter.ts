import { BaseReporter } from '../base-reporter';
import type { TestCatalog, TestSuite, TestCase } from '../../types';

/**
 * Markdown形式でレポートを出力するReporter
 * Jest --verbose風のシンプルな階層構造
 */
export class MarkdownReporter extends BaseReporter {
  /**
   * Markdown形式のレポートを生成
   */
  generate(): string {
    const catalog = this.catalog as TestCatalog;
    let markdown = '';

    // ヘッダー
    markdown += '# Test Catalog\n\n';
    markdown += `> Generated by Test Kanteen v${catalog.metadata.toolVersion}\n\n`;

    // メタデータ
    if (this.options.include?.metadata && catalog.metadata) {
      markdown += '## Metadata\n\n';
      markdown += `- **Generated At**: ${catalog.metadata.generatedAt}\n`;
      markdown += `- **Framework**: ${catalog.metadata.framework}\n`;
      markdown += `- **Source Files**: ${catalog.metadata.sourceFiles?.length || 0}\n`;
      markdown += `- **Test Suites**: ${catalog.testSuites?.length || 0}\n`;
      markdown += `- **Total Tests**: ${catalog.coverage.totalTests}\n\n`;
    }

    // 観点分布
    if (catalog.coverage && catalog.coverage.aspectCategories) {
      markdown += '## Aspects Distribution\n\n';
      for (const [category, count] of Object.entries(catalog.coverage.aspectCategories)) {
        const percentage = ((count / catalog.coverage.totalTests) * 100).toFixed(1);
        markdown += `- **${category}**: ${count} tests (${percentage}%)\n`;
      }
      markdown += '\n';
    }

    // テストスイート（Jest風の階層構造）
    if (catalog.testSuites && catalog.testSuites.length > 0) {
      markdown += '## Test Suites\n\n';
      markdown += '```\n';
      catalog.testSuites.forEach((suite) => {
        markdown += this.generateSuiteHierarchy(suite, 0);
      });
      markdown += '```\n\n';
    }

    // 観点サマリー
    if (this.options.include?.aspects && catalog.aspects && catalog.aspects.length > 0) {
      markdown += '## Test Aspects Summary\n\n';
      catalog.aspects.forEach((aspect) => {
        markdown += `### ${aspect.category}\n\n`;
        markdown += `${aspect.description}\n\n`;
        if (aspect.priority) {
          markdown += `**Priority**: ${aspect.priority.toUpperCase()}\n\n`;
        }
        markdown += `**Test Count**: ${aspect.testCases.length}\n\n`;
        if (aspect.examples && aspect.examples.length > 0) {
          markdown += '**Example Tests**:\n\n';
          aspect.examples.slice(0, 3).forEach((example) => {
            markdown += `- ${example}\n`;
          });
          markdown += '\n';
        }
      });
    }

    return markdown;
  }

  /**
   * Jest風の階層構造でスイートを生成
   */
  private generateSuiteHierarchy(suite: TestSuite, depth: number): string {
    let markdown = '';
    const indent = '  '.repeat(depth);

    // スイート名
    markdown += `${indent}${suite.name}\n`;

    // テストケース
    if (suite.tests && suite.tests.length > 0) {
      suite.tests.forEach((test) => {
        markdown += this.generateTestHierarchy(test, depth + 1);
      });
    }

    // ネストされたスイート
    if (suite.nestedSuites && suite.nestedSuites.length > 0) {
      suite.nestedSuites.forEach((nested) => {
        markdown += this.generateSuiteHierarchy(nested, depth + 1);
      });
    }

    return markdown;
  }

  /**
   * Jest風の階層構造でテストを生成
   */
  private generateTestHierarchy(test: TestCase, depth: number): string {
    const indent = '  '.repeat(depth);
    return `${indent}✓ ${test.name}\n`;
  }
}
